---
layout: post
title: All you need to know about String performance in Java  
tags:  
- todo

---

Strings are a basic and the most frequently used data type in almost every programming language, but do you know that with a single command you can reduce their memory consumption by TODO%? And this is only one of many tricks you should be aware of.

<!--excerpt-->

## How Strings are built in Java?

### String are immutable objects

The heart of String object is char array which stores its content. String is wrapping it and prevents from changing, offering multiple methods returning new strings as a result of computation.   

{% highlight java %}
/** The value is used for character storage. */
private final char value[];
{% endhighlight %}

Why are Strings immutable? Security and thread-safety are the good answers, but in terms of performance we will be mostly interested in objects caching, implemented via **String pool**. When you are creating a new string variable with value already existing in the pool, JVM doesn't have to create another entry, and reference to existing object would be returned. It helps to reduce memory consumption of Java programs as Strings are very common objects in any application. 

Immutability and caching are also helpful when computing String's hash, as it can be saved after first call to hashcode method. It gives performance boost when using structures like HashMaps, where hashes are required to determine to which bucket object should be put. 

{% highlight java %}
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        hash = h = isLatin1() ? StringLatin1.hashCode(value)
                              : StringUTF16.hashCode(value);
    }
    return h;
}
{% endhighlight %}  

### So, are Strings always returned from a pool?

No, they aren't, but the most convenient way of creating them - by string literal - works like that. Two strings literals from example below are not only equal in terms of value, but also share memory representation, pointing to one object in String pool. 

{% highlight java %}
String alice = "al" + "ice";
String bob = "alic" + "e";
System.out.println(alice.equals(bob));  // true
System.out.println(alice == bob);       // true
{% endhighlight %} 

There is another way of creating strings which involves calling its constructors. As a result, created objects will be separate entities with different memory representation. If comes without saying that it is not advised way of dealing with strings in Java.  

{% highlight java %}
String alice = new String("alice");
String bob = new String("alice");
System.out.println(alice.equals(bob));  // true
System.out.println(alice == bob);       // false
{% endhighlight %} 

You can manually place strings in their pool (or retrieve them if already exist) by calling String method intern().

{% highlight java %}
String alice = new String("alice");
String bob = new String("alice");
alice = alice.intern();
bob = bob.intern();
System.out.println(alice.equals(bob));  // true
System.out.println(alice == bob);       // true
{% endhighlight %} 

It is worth to mention that pool of literal values is not restricted to Strings. Other types in Java also supports this concept but in [a bit different way](https://stackoverflow.com/a/13098161).